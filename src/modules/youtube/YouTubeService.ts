import { YoutubeTranscript } from "youtube-transcript";

export class YouTubeService {
  /**
   * Extracts the video ID from various YouTube URL formats.
   */
  extractVideoId(url: string): string | null {
    const regex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/;
    const match = url.match(regex);
    return match ? match[1] : null;
  }

  /**
   * Fetches the transcript and basic metadata using a Federated Strategy.
   * 1. Piped API (Primary)
   * 2. Invidious API (Secondary)
   * 3. Local Library (Fallback)
   */
  async getTranscript(videoId: string): Promise<{ title: string; text: string } | null> {
    
    // --- Strategy 1: Piped API ---
    // Piped is a privacy-friendly YouTube frontend with a stable API.
    // Instances: https://pipedapi.kavin.rocks (Official), https://api.piped.nemb.one, etc.
    const pipedInstances = [
      "https://pipedapi.kavin.rocks",
      "https://api.piped.nemb.one",
      "https://pipedapi.adminforge.de"
    ];

    for (const instance of pipedInstances) {
      try {
        console.log(`[YouTubeService] Trying Piped instance: ${instance}`);
        const res = await fetch(`${instance}/streams/${videoId}`);
        if (!res.ok) continue;
        
        const data = await res.json() as any;
        const title = data.title || `YouTube Video (${videoId})`;
        const subtitles = data.subtitles || [];

        // Find English subtitle (auto or manual)
        const engSub = subtitles.find((s: any) => s.code === 'en' && !s.autoGenerated) 
                    || subtitles.find((s: any) => s.code === 'en')
                    || subtitles[0]; // Fallback to any

        if (engSub) {
          const subRes = await fetch(engSub.url);
          if (subRes.ok) {
            const vttText = await subRes.text();
            const cleanText = this.parseVTT(vttText);
            console.log(`[YouTubeService] Success via Piped (${instance})`);
            return { title, text: cleanText };
          }
        }
      } catch (e) {
        console.warn(`[YouTubeService] Piped instance ${instance} failed:`, e);
      }
    }

    // --- Strategy 2: Local Library (youtube-transcript) ---
    // This scrapes the page directly. Often blocked on Cloudflare, but worth a try.
    try {
      console.log(`[YouTubeService] Trying Local Library...`);
      const transcriptItems = await YoutubeTranscript.fetchTranscript(videoId);
      
      const fullText = transcriptItems
        .map((item) => item.text)
        .join(" ")
        .replace(/\s+/g, " ")
        .trim();

      // Fetch title via oembed
      let title = `YouTube Video (${videoId})`;
      try {
        const oembedRes = await fetch(`https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`);
        if (oembedRes.ok) {
          const data = await oembedRes.json() as any;
          if (data.title) title = data.title;
        }
      } catch {} // Ignore errors here

      console.log(`[YouTubeService] Success via Local Library`);
      return { title, text: fullText };
    } catch (e) {
      console.warn(`[YouTubeService] Local Library failed:`, e);
    }

    // --- Strategy 3: Invidious API ---
    // Another network of proxies.
    const invidiousInstances = [
      "https://inv.tux.pizza",
      "https://invidious.projectsegfau.lt",
      "https://invidious.kavin.rocks"
    ];

    for (const instance of invidiousInstances) {
      try {
        console.log(`[YouTubeService] Trying Invidious instance: ${instance}`);
        const res = await fetch(`${instance}/api/v1/videos/${videoId}`);
        if (!res.ok) continue;

        const data = await res.json() as any;
        const title = data.title;
        const captions = data.captions || [];

        const engCap = captions.find((c: any) => c.language === 'English') || captions[0];
        if (engCap) {
           const subRes = await fetch(`${instance}${engCap.url}`); // URL is relative usually
           if (subRes.ok) {
             const vttText = await subRes.text();
             const cleanText = this.parseVTT(vttText);
             console.log(`[YouTubeService] Success via Invidious (${instance})`);
             return { title, text: cleanText };
           }
        }
      } catch (e) {
        console.warn(`[YouTubeService] Invidious instance ${instance} failed:`, e);
      }
    }

    console.error(`[YouTubeService] All strategies failed for ${videoId}`);
    return null;
  }

  /**
   * Helper to parse simple WebVTT format to text.
   * Removes timestamps, headers, and styles.
   */
  private parseVTT(vtt: string): string {
    const lines = vtt.split('\n');
    let text = "";
    
    // Very basic VTT parser: skip header, skip timestamps (contain '-->'), skip empty/numbers
    for (const line of lines) {
      const l = line.trim();
      if (!l) continue;
      if (l.startsWith('WEBVTT')) continue;
      if (l.includes('-->')) continue;
      if (/^\d+$/.test(l)) continue; // Sequence numbers
      
      // Remove HTML-like tags <c>...</c> etc
      const cleanLine = l.replace(/<[^>]*>/g, "");
      text += cleanLine + " ";
    }
    
    return text.replace(/\s+/g, " ").trim();
  }
}

export const getYouTubeService = () => new YouTubeService();
