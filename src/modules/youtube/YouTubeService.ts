import { YoutubeTranscript } from "youtube-transcript";

export class YouTubeService {
  /**
   * Extracts the video ID from various YouTube URL formats.
   */
  extractVideoId(url: string): string | null {
    const regex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/; 
    const match = url.match(regex);
    return match ? match[1] : null;
  }

  /**
   * Fetches the transcript and basic metadata using a Federated Strategy.
   * 1. Piped API (Primary) - tries transcript, falls back to description.
   * 2. Local Library (Secondary) - direct scrape.
   * 3. OEmbed (Last Resort) - just title.
   */
  async getTranscript(videoId: string): Promise<{ title: string; text: string } | null> {
    
    // --- Strategy 1: Piped API ---
    // List of reliable Piped instances
    const pipedInstances = [
      "https://pipedapi.kavin.rocks",
      "https://api.piped.nemb.one",
      "https://pipedapi.adminforge.de",
      "https://api.piped.privacy.com.de",
      "https://pipedapi.drg.li",
      "https://pipedapi.smnz.de"
    ];

    for (const instance of pipedInstances) {
      try {
        console.log(`[YouTubeService] Trying Piped instance: ${instance}`);
        const res = await fetch(`${instance}/streams/${videoId}`);
        if (!res.ok) continue;
        
        const data = await res.json() as any;
        const title = data.title || `YouTube Video (${videoId})`;
        const description = data.description || "";
        const subtitles = data.subtitles || [];

        // 1a. Try to find Transcript
        const engSub = subtitles.find((s: any) => s.code === 'en' && !s.autoGenerated) 
                    || subtitles.find((s: any) => s.code === 'en')
                    || subtitles[0]; // Fallback to any language

        if (engSub) {
          const subRes = await fetch(engSub.url);
          if (subRes.ok) {
            const vttText = await subRes.text();
            const cleanText = this.parseVTT(vttText);
            console.log(`[YouTubeService] Success via Piped (${instance}) - Transcript`);
            return { title, text: cleanText };
          }
        }

        // 1b. Fallback to Description
        // If we can't find subtitles, the description is better than nothing for embeddings
        if (description) {
             console.log(`[YouTubeService] Success via Piped (${instance}) - Description Fallback`);
             return { title, text: description };
        }
        
      } catch (e) {
        console.warn(`[YouTubeService] Piped instance ${instance} failed:`, e);
      }
    }

    // --- Strategy 2: Local Library (youtube-transcript) ---
    try {
      console.log(`[YouTubeService] Trying Local Library...`);
      const transcriptItems = await YoutubeTranscript.fetchTranscript(videoId);
      
      const fullText = transcriptItems
        .map((item) => item.text)
        .join(" ")
        .replace(/\s+/g, " ")
        .trim();

      // Fetch title via oembed for completeness
      let title = `YouTube Video (${videoId})`;
      try {
        const oembedRes = await fetch(`https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`);
        if (oembedRes.ok) {
          const data = await oembedRes.json() as any;
          if (data.title) title = data.title;
        }
      } catch {} // Ignore errors here

      console.log(`[YouTubeService] Success via Local Library`);
      return { title, text: fullText };
    } catch (e) {
      console.warn(`[YouTubeService] Local Library failed:`, e);
    }

    // --- Strategy 3: OEmbed (Last Resort) ---
    // If we reach here, we likely have no transcript or description from proxies.
    // But we should at least return the Title so the user isn't blocked.
    try {
        console.log(`[YouTubeService] Trying OEmbed Fallback...`);
        const oembedRes = await fetch(`https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`);
        if (oembedRes.ok) {
          const data = await oembedRes.json() as any;
          console.log(`[YouTubeService] Success via OEmbed (Title Only)`);
          return { title: data.title, text: "" };
        }
    } catch (e) {
        console.warn(`[YouTubeService] OEmbed failed:`, e);
    }

    console.error(`[YouTubeService] All strategies failed for ${videoId}`);
    return null;
  }

  /**
   * Helper to parse simple WebVTT format to text.
   */
  private parseVTT(vtt: string): string {
    const lines = vtt.split('\n');
    let text = "";
    
    for (const line of lines) {
      const l = line.trim();
      if (!l) continue;
      if (l.startsWith('WEBVTT')) continue;
      if (l.includes('-->')) continue;
      if (/^\d+$/.test(l)) continue;
      
      const cleanLine = l.replace(/<[^>]*>/g, "");
      text += cleanLine + " ";
    }
    
    return text.replace(/\s+/g, " ").trim();
  }
}

export const getYouTubeService = () => new YouTubeService();